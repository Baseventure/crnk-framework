
# Angular Development with ngrx

NOTE: this feature is still in incurbation, feedback and contributions welcomed.

This chapter is dedicated to Angular development with Crnk,
https://github.com/ngrx/platform[ngrx] and
https://github.com/abdulhaq-e/ngrx-json-api[ngrx-json-api]. ngrx brings the redux-style application
development from React to Angular. Its motivation is to separate the presentation layer from
application state for a clean, mockable, debug-friendly, performant and scalable design.

We believe that JSON API and redux can complement each other well. The resource-based nature
of JSON API and its normalized response document format (trough relationships and inclusions)
are well suited to be put into an ngrx-based store. ngrx-json-api is a project that does exactly that.

The last piece is how to integrate Angular components like forms and tables with ngrx-json-api.
Tables need to display JSON API resources with sorting, filtering, paging and error handling.
While forms need to display a JSON API resource with support to trigger `POST`, `PATCH` and `DELETE`
methods including validation resp. general error handling. For this purpose crnk provides to tools:
crnk-gen-typescript and crnk-client-ngrx. crnk-gen-typescript provides the means for  crnk-client-ngrx
to do compile-time safe development. But crnk-client-ngrx can also be used standalone without crnk-gen-typescript.
For more information about Typescript generation have a look
at the <<generation>> chapter.



## Feature overview

crnk-client-ngrx provides a number of different components:

[cols="20,80"]
|===
| Import
| Description

| @crnk/angular-ngrx/operations
| `CrnkOperationsModule` implements JSON PATCH as Angular module. The module hooks into ngrx-json-api and enhances it with
  bulk insert, update, delete capabilities.

| @crnk/angular-ngrx/expression
| A simple QueryDSL-like expression model for Typescript.

| @crnk/angular-ngrx/expression/forms
| Binding of the expression model to Angular form components (a JSON API specific flavor of `ngModel`).

| @crnk/angular-ngrx/binding
| Helper classes that take care of binding tables or forms to JSON API. Makes use of `@crnk/angular-ngrx/expression`.

| @crnk/angular-ngrx/meta
| Typescript API for <<meta_module|Meta Module>> generated with crnk-gen-typescript.

| @crnk/angular-ngrx/stub
| Some minor base classes used by Typescript generator. Not of direct interest.
|===

All of those components are fairly lightweight and then also be used independently (if not specified otherwise above).


## Bulk support with JSON Patch

`CrnkOperationsModule` imported from `@crnk/angular-ngrx/operations` provides client side support
for JSON PATCH. This enables clients to issue bulk requests. See <<operations_module,Operations module>> for
more information about how it is implemented in Crnk.

`CrnkOperationsModule` integrates into `NgrxJsonApiModule` by providing a new `OperationsInitAction` that is a
drop-in replacement for `ApiApplyInitAction` of ngrx-json-api. Instead of issuing multiple requests, it will then
issue a single bulk JSON Patch request. The bulk response triggers the usual `ApiApplySuccessAction` resp.
`ApiApplyFailAction`.

Have a look at `crnk.operations.effects.spec.ts` for a test case demonstrating its use.


## Expressions

`@crnk/angular-ngrx/expression` provides a QueryDSL-like expression model for Typescript. It is used  to
 address boiler-plate when working with the Angular `FormModule` resp. `ngModel` directly. For example,
 when an input field nees to be bound to a JSON API resource field, a number of things must happen:

 - The input field should display the current store value.
 - The input field must have a unique form name.
 - The input field must sent changes back to the store.
 - The `FormControl` backing the input field must have a proper valid state. The errors of the JSON API resource
    may contain a source pointer. If the source pointer points to the field in question, it needs to be accounted for
    in the valid state.
 - The input field is usually accompanied by a message field showing any validation issue.

`ngModel` is limited to holding a value, but the use cases here require the full resource, the path to the field and
the field value. This is achieved with:

- `Expression` interface that represents any kind of value that can be obtained in some fashion.
- `Path<T>` implements `Expression` and refers to a property of type `<T>` in an object.
- For nested paths like `attribute.name` two path objects are created.
- `StringPath`, `NumberPath`, `BooleanPath` and `BeanPath<T>` are type-safe implementations of path.
- `BeanBinding` implements `Path` and represents the root, usually a resource.

Such expressions and paths can be constructed manually. Or, in most cases, `crnk-gen-typescript` can take
care of that. In this case usage looks like:

[source]
.crnk.expression.spec.ts
----
include::../../../../crnk-client-angular-ngrx/test/crnk.expression.spec.ts[tag=docs]
----

Note that:

- `QMetaAttribute` from the meta model is used as example resource. At some point a dedicated test model
  will be setup.
- it is fully type-safe
- `getValue` fetches the value of the given path.
- `setValue` sets the value of the given path.
- `toString` returns the string representation of the path separated by dots.
- `getResource` returns the object resp. resource backing the path.
- `toFormName` computes a default (unique) form name for that path. The name is composed of the
  resource type, resource id and path to allow editing of multiple resources on the same screen.
- QMetaAttribute can also be constructed without a bean binding. In this case it can still
  be used to construct type-safe paths and call `toString`. This can be used, for example, to specify
  a field for a table column where only later multiple records will then be loaded and shown.

The `CrnkBindingFormModule` provides two directives `crnkExpression` and `crnkFormExpression` that
represent the `ngModel` counter-parts for expressions. While the former is be used standalone,
the later is used for forms and registers itself the `ngForm` with the name provided
by `toFormName`. Usage can look like:

[source]
----
<input id="nameInput" [crnkExpression]="resource.attributes.name"/>
----

or

[source]
----
<input id="nameInput" required [crnkFormExpression]="resource.attributes.name"/>
----

The use of expressions provides an (optional) foundation for the form and table binding discussed
in the next sections.

## Form Binding

Working with forms and JSON API is the same for most use cases:

- components are bound to store values
- components have to update store values by dispatching appropriate actions
- components may perform some simple local validation like with the Angular `required` directive.
- components may get server-side validation errors using the JSON API error format.
- components may perform client-side validation within the store. The JSON API
  error mechanism is reused for this purpose. The `ModifyStoreResourceErrorsAction`
  action can be triggered by an effect listing to value changes and makes arbitrarily complex, client-side
  validation logic possible.

There is a `FormBinding` class provided by `CrnkExpressionFormModule` that takes care of exactly this:

[source]
.crnk.test.editor.component.ts
----
include::../../../../crnk-client-angular-ngrx/test/crnk.test.editor.component.ts[]
----

A template then looks like:

[source]
.crnk.test.editor.component.html
----
include::../../../../crnk-client-angular-ngrx/test/crnk.test.editor.component.html[]
----

Note that:

- It is fully type-safe.
- It is compact.
- There are two flavors to display errors. Only one is needed for a real application.
  Usually `crnk-control-errors` is used and allows to display any `FormControl` validation issue,
  either from a local validator or from the JSON API resource.
  `crnk-resource-errors` is a standalone flavor that is not bound to any `FormControl` and displays
  JSON API errors only. In both case a template must be specified how the error is rendered.
  In case of multiple errors, the template is rendered multiple times. `errorCode` and `errorData`
  are available as variable. `errorData` contains the full JSON API error object in case of
  a JSON API error.
- `FormBinding` does not push changes to the store as long as local validation (`required`, `min-length`, etc.)
  do not pass.
- `FormBinding` makes use of the form name to update the store. Therefore, the use of the expression model
  is optional and applications can also continue making use of `ngModel` and `formControlName` where
  appropriate. The name of form controls can follow to patterns: `//<type>//<id>//path` or just
  `path``. The form allows to modify multiple resources, while the later assumes the primary
  resource loaded by the query is being modified.

The Angular `FormModule` gives a number of restrictions. In the future we expect to also support the use
`FormBinding` without a `NgForm` instance (for some performance and simplicity benefits). Please
provide feedback in this area of what is most helpful.


## Table Binding

Similar to `FormBinding` there is a `TableBinding` class that looks like:

[source]
.crnk.test.table.component.ts
----
include::../../../../crnk-client-angular-ngrx/test/crnk.test.table.component.ts[]
----

and

[source]
.crnk.test.table.component.html
----
include::../../../../crnk-client-angular-ngrx/test/crnk.test.table.component.html[]
----

Note that:

- Also type-safe with the generated `MetaAttributeListResult`.
- It currently is limited to the PrimeNG `DataTable`, but PRs for other implementations are welcomed.
- `TableBinding.onLazyLoad` translates PrimeNG query, sort and page parameters to JSON API parameters.

## Meta Model

Typescript API for <<meta_module|Meta Module>> generated with crnk-gen-typescript.






